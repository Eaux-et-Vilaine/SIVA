---
title: "flat_debit.Rmd"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# Debit d'une vanne

 Fonction de calcul de débit pour une vanne
 Choisir canal="bazin" pour avoir les calculs qui étaient fait avant 2018 au
barrage.  Aubuisson et horton pour calculer les débits suivant Ferrette (2004)
en prenant ou non compte des vitesses  Par rapport à Ferette (2004), la formule
en orifice dénoyé calcule les vitesses par iteration.  Le calcul est effectué à
partir d'une indexation des conditions de débits (vecteur de valeurs vrai et
faux) entre crochet.  Les coefficients de Bazin ont été recalculés par une
'regression' loess sur la base du rapport annexé à Briand et Woimant (2015)


```{r function-debit_vanne}
#' Fonction de calcul du débit d'une vanne au barrage d'Arzal
#' 
#' Fonction de calcul de débit pour une vanne
#' Choisir canal="bazin" pour avoir les calculs au barrage
#' Aubuisson et horton pour calculer les débits suivant Ferrette (2004) en prenant ou non compte des vitesses
#' Par rapport à Ferette (2004), la formule en orifice dénoyé calcule les vitesses par iteration.
#' Le calcul est effectué à partir d'une indexation des conditions de débits (vecteur de valeurs vrai et faux) entre crochet.
#' Les coefficients de Bazin ont été recalculés par une 'regression' loess sur la base du rapport annexé à Briand et Woimant (2015)
#'
#' @param hvilaine Vecteur de données des niveaux Vilaine.
#' @param hmer Vecteur de données des niveaux mer.
#' @param hvanne Vecteur de données des hauteurs de vanne.
#' @param l Largeur de la vanne, défaut 18.
#' @param g 9.81.
#' @param canal Loi de débit choisir "bazin", "aubuisson", "horton", "manning" ou "ifsw".
#' @param dm Distance à la sonde amont pour formle de Basin défaut 73.
#' @param dv Distance à la sonde aval pour formule de Bazin défaut 94.
#' @param Cma Coefficient canal pour Manning défaut 0.65.
#' @param Cho Coefficient canal pour Horton défaut .79.
#' @param m_oninf4 Coefficient Orifice noyé noyé hvanne<4 (Ferrette) défaut 0.663.
#' @param m_onsup4 Orifice noyé hvanne >4 défaut 0.995.
#' @param Cvw Coefficient ifsw canal défaut 1.
#' @param Cvg Coefficient ifsw orifice h1<=1.5 hvanne défaut 1.5.
#' @param Cvgs Coefficient ifsw h1>1.5 hvanne défaut 1.5.
#' @param loi_orificenoye défaut "ifws", choisir "ferrette" ou "ifws".	
#'
#' @return Un tableau de données avec deux colonnes, "Q" le débit calculé en m3/s et "typecalc" 
#' le type de calcul "vanne fermee", "hmer>hvilaine", "canal aubuisson", "canal horton", "canal bazin",
#' "canal manning", "canal ifsw (noye)", "canal ifsw (libre)", "orifice noye (ferr)", "orifice noye (ifws) inf1.5" ou
#' "orifice noye (ifws) sup1.5".	
#' @export
#' @author Cedric Briand \email{cedric.briand@eaux-et-vilaine.bzh}, Stephanie Woimant \email{stephanie.woimant@eaux-et-vilaine.bzh} 
debit_vanne <- function(hvilaine, # vecteur
    hmer, #vecteur
    hvanne, # vecteur
    l=18, # largeur de la vanne
    g=9.81,
    canal="ifsw", # choisir bazin, aubuisson ou horton ou manning ou ifsw
    dm=73, #distance à la sonde amont pour formle basin
    dv=94, # distance à la sonde aval pour formule bazin
    Cma=0.65, #coefficient canal pour manning 
    Cho=.79, #coefficient canal pour horton
    m_oninf4=0.663, # Coefficient Orifice noyé noyé hvanne<4 (ferrette)
    m_onsup4=0.995, #Orifice noyé hvanne >4
    #m_od=0.65, # coefficient orifice dénoyé par l'aval (on n'utilise plus cette condition)
    Cvw=1, # coefficient ifsw canal
    Cvg=1.5, #coefficient ifsw orifice h1<=1.5 hvanne
    Cvgs=1.5, # coefficient ifsw h1>1.5 hvanne
    loi_orificenoye="ifws"#choisir "ferrette" ou ifws		
){
  # test initial	
  if (!(length(hmer)==length(hvilaine)&length(hmer)==length(hvanne))) stop("hmer, hmvilaine, hvanne doivent avoir la même longueur")
  #initialisation des variables
  res<-data.frame("hvilaine"=hvilaine,"hmer"=hmer,"hvanne"=hvanne)
  res$Q<-rep(NA,length(hmer)) 
  res$typecalc<-rep(NA,length(hmer))
  h2<-hmer+7.72
  h1<-hvilaine+7.72
  delta<-hvilaine-hmer # y dans la formule
  # Conditions de calcul pour formules hydrauliques
  loicanal<-delta>0&hvanne>0&hvilaine<=(hvanne-7.72)
  loicanal[is.na(loicanal)]<-FALSE # pour éviter le plantiage lors de la réindexation
  loinoye<-delta>0&hvanne>0&hvilaine>(hvanne-7.72)#&hmer>=(hvanne-7.72)
  loinoye[is.na(loinoye)]<-FALSE
  # On n'utilise plus les loi dénoyé par l'aval (orifice)
  #loidenoye<-delta>0&hvanne>0&hvilaine>(hvanne-7.72)&hmer<(hvanne-7.72)
  #loidenoye[is.na(loidenoye)]<-FALSE
  # Situations ou le débit est nul
  res$Q[hvanne==0]<-0
  res$typecalc[hvanne==0]<-"vanne fermee"
  res$Q[delta<=0]<-0
  res$typecalc[delta<=0]<-"hmer>hvilaine"	

# I CALCULS EN LOI DITE 'DE CANAL' ---------------------------------------------

  if (sum(loicanal)>0){
	
# I1- formule d'aubuisson simplifiée --------------------------------------------
	
    if (canal=="aubuisson"){
      
      res$typecalc[loicanal]<-"canal aubuisson"
      m=0.9
      res$Q[loicanal]= m*l*h2[loicanal]*(2*g*delta[loicanal])^1/2
      # Note Ferrette la formule est fausse !
      # la formule ci-dessus correspond au calcul d'Aldo

# I2- formule d'aubuisson complète (Horton) ------------------------------------------
			
    }  else if (canal=="horton"){
      # Même formule mais avec coeff de vitesse
      res$typecalc[loicanal]<-"canal horton"			
      a<-0.035
      Q0<-Cho*l*h2[loicanal]*(2*g*delta[loicanal])^1/2
      V<-Q0/(l*hvanne[loicanal])
      Q<-Cho*l*h2[loicanal]*(2*g*delta[loicanal]+a*(1.2*V)^2)^1/2
      res$Q[loicanal]<-Q

# I3- formule de Bazin (telle que calculée au barrage) -----------------------------------
	
    } else if (canal=="bazin"){
      load(file=str_c(datawd,"loess_gamma_bazin.Rdata"))
      res$typecalc[loicanal]<-"canal bazin"
      # Dm=73
      # Dv=94
      # formules du barrage
      # les calculs font intervenir des sondes plus distantes ????
      I<-delta/(dm+dv) # pente hydraulique
      H<-hmer+I*dv+7.72 # # hauteur d'eau au niveau de la vanne
      #Rh=S/perimetre mouille
      Rh=l*H/(2*H+l)
      gamma<-predict(loess_gamma_bazin,data.frame(H=H[loicanal]))
      res$Q[loicanal]<-gamma*H[loicanal]*l*sqrt(I[loicanal])

# I4- formule de Manning ------------------------------------------------------------------
		
    } else if (canal=="manning"){
      # Formule de Manning-Strickler
      # m coefficient de contraction 0.70
      res$typecalc[loicanal]<-"canal manning"
      res$Q[loicanal]<-Cma*(h1[loicanal])*l*sqrt(2*g*delta[loicanal])
      #####################################	
# I5- formule utilisée dans Briand & Woimant (2015) ce rapport
      #####################################				
    }	 else if (canal=="ifsw"){
      # pour la formule il faut d'abord calculer un coefficient de débit.
      # delta=0.01
      # 40 = longueur du radier ?
      # 2 = longueur du bout (rond) du radier ?
      # 18 = largeur=l
      Cd<-((1-0.01*(10)/l)*(1-(0.01/2*h1)*(10)))^1.5	
      canaldenoye<-((h2/h1)<=0.98) & loicanal # free weir flow under gate
      canalnoye<-((h2/h1)>0.98) & loicanal # drowned weir flow under gate
      
      res$Q[canaldenoye]<-Cd[canaldenoye]*Cvw*(2/3)^1.5*g^0.5*l*h1[canaldenoye]^1.5
      res$typecalc[canaldenoye]<-"canal ifsw (libre)"	
      
      res$Q[canalnoye]<-Cd[canalnoye]*Cvw*(2/3)^1.5*g^0.5*l*h1[canalnoye]*((h1[canalnoye]-h2[canalnoye])/(1-0.98))^0.5				
      res$typecalc[canalnoye]<-"canal ifsw (noye)"
      
    }	else	{			
      stop("canal doit être bazin, aubusson,  horton, manning ou ifsw")
    } # end canal
  }
	
# II CALCULS EN LOI 'ORIFICE NOYE' ---------------------------------------------

  if (sum(loinoye)>0){

# II 1- formule de ferrette (2004) ---------------------------------------------
	#
    if (loi_orificenoye=="ferrette"){
      m_on<-ifelse(hvanne[loinoye]<4,m_oninf4,m_onsup4) # source fichiers Aldo
      # U1 calculé par itérations successives
      Q0<-rep(0,sum(loinoye)) # vecteur des débits conditions initiales
      Q<-rep(1,sum(loinoye)) # vecteur des débits conditions initiales
      #i<-0
      V<-rep(1,sum(loinoye)) # vecteur des vitesses
      e<-hvanne[loinoye]
      H<-h2[loinoye]
      
      while(any(abs(Q-Q0)>0.01)){
        #cat(i)
        Q0<-m_on*l*e*(2*g*(delta[loinoye]+V^2/(2*g)))^1/2
        #cat(str_c(Q0[1],"\n"))
        V<-pmin(7,Q0/(l*H)) #sinon on a des infinis
        Q<-m_on*l*e*(2*g*(delta[loinoye]+V^2/(2*g)))^1/2
        #i<-i+1
      }
      res$Q[loinoye]<-Q
      res$typecalc[loinoye]<-"orifice noye (ferr)"	

# II 2 - formule utilisée dans Briand & Woimant (2015) --------------------------------
		
    } else if (loi_orificenoye=="ifws"){
      #noyage vanne
      loinoyeinf1.5<-(h1<=1.5*hvanne)&loinoye
      loinoyesup1.5<-(h1>1.5*hvanne)&loinoye
      ce<-0.61*(1+0.15*(l+2*hvanne)/(2*l+2*hvanne))
      Q<-ce[loinoyeinf1.5]*Cvg*hvanne[loinoyeinf1.5]*l*sqrt(2*g*delta[loinoyeinf1.5])
      res$Q[loinoyeinf1.5]<-Q
      res$typecalc[loinoyeinf1.5]<-"orifice noye (ifws) inf1.5"	
      Q<-ce[loinoyesup1.5]*Cvgs*hvanne[loinoyesup1.5]*l*sqrt(2*g*delta[loinoyesup1.5])
      res$Q[loinoyesup1.5]<-Q
      res$typecalc[loinoyesup1.5]<-"orifice noye (ifws) sup1.5"					
    }
  }

# III ORIFICE DENOYE (cette condition n'est plus appliquée car elles n'apparaît que marginalement pour
# des grandes ouvertures de vannes --------------------------------------------------------------

  
#	if (sum(loidenoye)>0){
#			res$typecalc[loidenoye]<-"orifice denoye ferrette"			
#			res$Q[loidenoye]<-m_od*l*hvanne[loidenoye]*sqrt(2*g*h1[loidenoye]/(1+m_od*hvanne[loidenoye]/h1[loidenoye]))
#		}
  return(res)	
}
```

```{r examples-debit_vanne}
# Exploration des coefficients la formule de Bazin 

H=c(5:11)
Rh=c(2,2.25,2.5,2.8,3,3.2,3.4)
K=c(118,125,133,140,146,152,156)
plot(Rh,K)
points(Rh,predict(lm(K~Rh)),type="l")
gamma=87*Rh/(K+sqrt(Rh))
plot(H,gamma,pch="A")
df<-data.frame(H=H,gamma=gamma)
loess_gamma_bazin<-loess(gamma~H,data=df,control = loess.control(surface = "direct")) # contol pour extrapolation en dehors de la gamme
#save(loess_gamma_bazin,file=str_c(datawd,"loess_gamma_bazin.Rdata"))
df2<-data.frame(H=seq(from=5,to=11,by=0.1)) # pour les prédictions
df2$gamma<-predict(loess_gamma_bazin,newdata=df2)
points(df2$H,df2$gamma,col="red")

# utilisation de la fonction de débit pour une vanne
#TODO



```

```{r tests-debit_vanne}
test_that("La fonction de calcul de débit-vanne fonctionne", {
#TODO
})
```




# Débit de l'ensemble des vannes : debit_vannes
    
```{r function-debit_vannes}
#' débit de l'ensemble des vannes du barrage d'Arzal
#' 
#' Le débit de toutes les vannes est calculé à partir de la fonction de calcul du débit sur une vanne
#' et des coefficients de débit
#' 
#' @return
#' 
#' @export
debit_vannes<-function(horodate,hvanne1,hvanne2,hvanne3,hvanne4,hvanne5,hvilaine,hmer,canal="manning",
    Cma=0.65, #coefficient de manning à ajuster
    Cho=.79, #horton
    m_oninf4=0.663, # Orifice noyé noyé hvanne<4
    m_onsup4=0.995, #Orifice noyé hvanne >4
    Cvg=1.5, #coefficient ifsw orifice h1<=1.5 hvanne
    Cvgs=1.5, # coefficient ifsw h1>1.5 hvanne
    Cvw=1.5,
    loi_orificenoye="ifws"
) {
  Qva1<-debit_vanne(hvilaine=hvilaine, hmer=hmer, hvanne=hvanne1, canal=canal,Cma=Cma, Cho=Cho, m_oninf4=m_oninf4,m_onsup4=m_onsup4,Cvg=Cvg,Cvgs=Cvgs,Cvw=Cvw,loi_orificenoye="ifws")
  Qva2<-debit_vanne(hvilaine=hvilaine, hmer=hmer, hvanne=hvanne2, canal=canal,Cma=Cma, Cho=Cho, m_oninf4=m_oninf4,m_onsup4=m_onsup4,Cvg=Cvg,Cvgs=Cvgs,Cvw=Cvw,loi_orificenoye="ifws")
  Qva3<-debit_vanne(hvilaine=hvilaine, hmer=hmer, hvanne=hvanne3, canal=canal,Cma=Cma, Cho=Cho, m_oninf4=m_oninf4,m_onsup4=m_onsup4,Cvg=Cvg,Cvgs=Cvgs,Cvw=Cvw,loi_orificenoye="ifws")
  Qva4<-debit_vanne(hvilaine=hvilaine, hmer=hmer, hvanne=hvanne4, canal=canal,Cma=Cma, Cho=Cho, m_oninf4=m_oninf4,m_onsup4=m_onsup4,Cvg=Cvg,Cvgs=Cvgs,Cvw=Cvw,loi_orificenoye="ifws")
  Qva5<-debit_vanne(hvilaine=hvilaine, hmer=hmer, hvanne=hvanne5, canal=canal,Cma=Cma, Cho=Cho, m_oninf4=m_oninf4,m_onsup4=m_onsup4,Cvg=Cvg,Cvgs=Cvgs,Cvw=Cvw,loi_orificenoye="ifws")
  return(data.frame(horodate=horodate,
          qvanne1=Qva1$Q,
          qvanne2=Qva2$Q,
          qvanne3=Qva3$Q,
          qvanne4=Qva4$Q,
          qvanne5=Qva5$Q,
          Q=Qva1$Q+Qva2$Q+Qva3$Q+Qva4$Q+Qva5$Q,
          typecalc1=Qva1$typecalc,
          typecalc2=Qva2$typecalc,
          typecalc3=Qva3$typecalc,
          typecalc4=Qva4$typecalc,
          typecalc5=Qva5$typecalc												
      ))
}
```
  
```{r example-debit_vannes}
debit_vannes()
```
  
```{r tests-debit_vannes}
test_that("debit_vannes works", {
  expect_true(inherits(debit_vannes, "function")) 
})
```

# Débit d'un volet : debit_volet

Le fonctionnement en volet est déduit de l'absence d'ouverture de vanne, de la
position du codeur, du niveau Vilaine et du niveau mer. Il semble, mais ce point
reste à confirmer, que la formule par défaut du barrage ne calcule que pour les
positions de codeur au dessus du fin de course (>1.38). La hauteur du volet
varie en théorie entre 1.38 et 4.03 m NGF. En pratique il y a des dérives du
niveau du codeur qui font qu'on ne peut utiliser que l'information sur la baisse
du volet et une valeur approximative permettant de sélectionner les positions
volet ouvert (<3.5m).

$$
si~&h_{vilaine}\geq 1.38~\& \\ &h_{volet}<3.5~\&\\ &h_0=0~\&\\
&h_{vilaine}>h_{mer}+0.3\\
&Q_{vo}=l'*\mu_{vo}(\frac{2}{3}g)^{0.5}(h_{vilaine}-1.38)^{1.5} 
$$
    
```{r function-debit_volet}
#' Débit d'un volet
#' 
#' Formule déversoir à crête épaisse (Ferrette, 2004).
#' 
#' @return
#' 
#' @export
debit_volet = function(hvolet,
                       hvilaine,
                       hvanne,
                       hmer,
                       Cvo = 0.392,
                       g = 9.81,
                       l = 16.4) {
  H0 = ifelse(hvilaine >= 1.38 &
                hvolet < 3.5 & hvanne == 0 & hvilaine > hmer + 0.3,
              hvilaine - 1.38,
              0)
  Q = l * Cvo * (2 / 3 * g) ^ 0.5 * (H0) ^ 1.5
}
```
  
```{r example-debit_volet}
debit_volet()
```
  
```{r tests-debit_volet}
test_that("debit_volet works", {
  expect_true(inherits(debit_volet, "function")) 
})
```

# Débit de l'ensemble des volets : debit_volets
    
```{r function-debit_volets}
#' Calcul du débit sur tous les volets
#' 
#' Somme du débit de tous les volets
#' 
#' @return
#' 
#' @export
debit_volets <-
  function(hvolet1,
           hvolet2,
           hvolet3,
           hvolet4,
           hvolet5,
           hvilaine,
           hvanne1,
           hvanne2,
           hvanne3,
           hvanne4,
           hvanne5,
           hmer,
           Cvo = 0.392) {
    Qv1 <- debit_volet(hvolet1, hvilaine, hvanne1, hmer, Cvo)
    Qv2 <- debit_volet(hvolet2, hvilaine, hvanne2, hmer, Cvo)
    Qv3 <- debit_volet(hvolet3, hvilaine, hvanne3, hmer, Cvo)
    Qv4 <- debit_volet(hvolet4, hvilaine, hvanne4, hmer, Cvo)
    Qv5 <- debit_volet(hvolet5, hvilaine, hvanne5, hmer, Cvo)
    return(
      data.frame(
        "Qvolet1" = Qv1,
        "Qvolet2" = Qv2,
        "Qvolet3" = Qv3,
        "Qvolet4" = Qv4,
        "Qvolet5" = Qv5
      )
    )
  }
```
  
```{r example-debit_volets}
debit_volets()
```
  
```{r tests-debit_volets}
test_that("debit_volets works", {
  expect_true(inherits(debit_volets, "function")) 
})
```

# Débit de l'ensemble du barrage : debit_vannes_volet
    
```{r function-debit_total}



#' Débit de l'ensemble des volets et des vannes du barrage.
#' 
#' Débit total (cette fonction retourne le débit total journalier et la valeur moyenne
#' Pondérée du débit de Cran.) en utilisant les choix IFSW pour les fonctions de débit
#' Briand et Woimant (2015). Le calcul se fait en utilisant canal="ifsw" et loi_orificenoye = "ifws".
#' 
#' 
#'
#' @param param Les paramètres à optimiser (4 paramètres "Cvo","Cvg","Cvgs","Cvw") voir 
#' @param param0 
#' @param dat 
#' @note Cette fonction a été utilisée pour optimiser les coefficients de débit, 
#' param est consititué des coefficients optimisés
#' mais il faut les autres qui sont stocké dans param0 pour faire tourner débit_total
#' Ainsi a_optimiser tourne bien sur param mais débit total sur param + les coeff de param0.
#' CHANGEMENT 2016 la référence devient niveaumerb et niveauVilaineb.
#' 
#'
#' @return  Un data frame avec 
#' date = la date (au format date),
#' Qva12345 = la somme des débits des vannes 1 à 5, 
#' Qvo12345 = la somme des débits des volets 1 à 5,
#' tot_vol_ecluse = le volume total de l'écluse, tot_vol_siphon = le volume total du siphon, 
#' tot_vol_passe = le volume total de la passe, 
#' debit_moyen_cran = le débit moyen journalier au pont de Cran			 
#' @export
debit_total <-
  function(param = c(
    "Cvo" = 0.392,
    "Cvg" = 1.5,
    "Cvgs" = 1.5,
    "Cvw" = 1.5
  ),
  param0,
  dat) {
    if (length(param) < 4)
      param <- c(param, param0[!names(param0) %in% names(param)])
    dat$niveauvilaineb[is.na(dat$niveauvilaineb)] <-
      dat$niveauvilaine[is.na(dat$niveauvilaineb)]
    dat$niveaumerb[is.na(dat$niveaumerb)] <-
      dat$niveaumer[is.na(dat$niveaumerb)]
    Qvo12345 <- debit_volets(
      hvolet1 = dat$volet1,
      hvolet2 = dat$volet2,
      hvolet3 = dat$volet3,
      hvolet4 = dat$volet4,
      hvolet5 = dat$volet5,
      hvilaine = dat$niveauvilaineb,
      hmer = dat$niveaumerb,
      hvanne1 = dat$vanne1,
      hvanne2 = dat$vanne2,
      hvanne3 = dat$vanne3,
      hvanne4 = dat$vanne4,
      hvanne5 = dat$vanne5,
      param["Cvo"]
    )
    Qvo12345$volvoletcalcule <- rowSums(Qvo12345) * 600
    Qva12345 <- debit_vannes(
      horodate = dat$HoroDate,
      hvanne1 = dat$vanne1,
      hvanne2 = dat$vanne2,
      hvanne3 = dat$vanne3,
      hvanne4 = dat$vanne4,
      hvanne5 = dat$vanne5,
      hvilaine = dat$niveauvilaineb,
      hmer = dat$niveaumerb,
      canal = "ifsw",
      # choix bazin, aubuisson ou horton ou manning ou ifsw
      Cvg = param["Cvg"],
      #coefficient ifsw orifice h1<=1.5 hvanne
      Cvgs = param["Cvgs"],
      # coefficient ifsw h1>1.5 hvanne
      Cvw = param["Cvw"],
      #coefficient ifsw écoulement surface libre (canal)
      loi_orificenoye = "ifws"#"ferrete"
    )
    Q12345 <-
      cbind(
        Qva12345,
        Qvo12345,
        "tot_vol_ecluse" = dat$tot_vol_ecluse,
        "tot_vol_siphon" = dat$tot_vol_siphon,
        "tot_vol_passe" = dat$tot_vol_passe
      )
    Q12345$date = as.Date(Q12345$horodate)
    Q12345$debit_moyen_cran <- dat$debit_moyen_cran
    return(Q12345)
}
```
  
```{r example-debit_total}
debit_total()
```
  
```{r tests-debit_total}
test_that("debit_total fonctionne", {
  expect_true(inherits(debit_total, "function")) 
})
```


  
```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_debit.Rmd", vignette_name = "Go further")
```


  