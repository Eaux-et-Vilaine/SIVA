---
title: "SIVAplot"
params: 
  debut: !r Sys.Date()-10
  fin: !r Sys.Date()
---

```{r init, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
list=ls(all=TRUE)
library(safer)
library(getPass)
if (!exists("mainpass")) mainpass <- getPass(msg="Main password")
list<-list[-match(c("passworddistant","passwordlocal","umysql","pwdmysql"),list)  ]
rm(list) # nettoyage complet
debut<-as.character(params$debut)
fin<-as.character(params$fin)
load_library=function(necessary) {
  if(!all(necessary %in% installed.packages()[, 'Package']))
    install.packages(necessary[!necessary %in% installed.packages()[, 'Package']], dep = T)
  for(i in 1:length(necessary))
    library(necessary[i], character.only = TRUE)
}
load_library('stringr') # text handling
load_library('RODBC')
load_library('stacomirtools') # fonctions de requetage odbc 
load_library('lubridate')
#install.packages('RMySQL',type='source')
#library(RMySQL)
load(system.file("param2012_2014.Rdata", package = "SIVA"))
load_library('RPostgreSQL') # one can use RODBC, here I'm using direct connection load_library('ggplot2')# join fuction
load_library('lubridate')
load_library('reshape2')
load_library('tidyverse')	

#'==========================================================
#' fonction d'application de la transparence à des couleurs.
#'==========================================================
makeTransparent<-function(someColor, alpha=100)
{
  newColor<-col2rgb(someColor)
  apply(newColor, 2, function(curcoldata){rgb(red=curcoldata[1], green=curcoldata[2],
                                              blue=curcoldata[3],alpha=alpha, maxColorValue=255)})
}	#note: always pass alpha on the 0-255 scale

#'==========================================================
#' Définition du nom des couleurs
#'==========================================================

bleu_EV <- "#00218f"
turquoise_EV <- "#00C9C4"
orange_EV <- "#ff7557"
jaune_EV <- "#ffb428"
bleu_EVf <- "#001350"
jaune_EVf <- "#AD7000"
orange_EVf <- "#b2513c"
bleu_clair_EV <- "#33b5ff"
turquoise_EVf <- "#007873"

library(SIVA)


```

Les données seront chargées de `r debut` à `r fin`


# Plot des données de débit

```{r loaddebit}

#if (interactive()){
if (!exists("mainpass")) mainpass <- getPass::getPass(msg = "main password")
if (!exists("hostmysql")) {
  hostmysql. <- getPass::getPass(msg = "Saisir host")
  # ci dessous pour ne pas redemander au prochain tour
  hostmysql <- encrypt_string(string = hostmysql., key = mainpass)
} else {
  hostmysql. <- decrypt_string(string = hostmysql, key = mainpass)
}
if (!exists("pwdmysql")) {
  pwdmysql. <- getPass::getPass(msg = "Saisir password")
  pwdmysql <- encrypt_string(string = pwdmysql., key = mainpass)
}  else {
  # pass should be loaded
  pwdmysql. <- decrypt_string(string = pwdmysql, key = mainpass)
}
if (!exists("umysql")) {
  umysql. <- getPass::getPass(msg = "Saisir user")
  umysql <- encrypt_string(string = umysql., key = mainpass)
} else {
  umysql. <- decrypt_string(string = umysql, key = mainpass)
}
# attention il faut avaoir définit mainpass <- "xxxxx"

pool <- pool::dbPool(
  drv = RMariaDB::MariaDB(),
  dbname = "archive_IAV",
  host = hostmysql.,
  username = umysql.,
  password = pwdmysql.,
  port=3306
)


system.time(debit_barrage <-
              load_debit_barrage (debut = as.POSIXct(
                strptime("2018-01-01 00:00:00", format = "%Y-%m-%d %H:%M:%S")
              ),
              fin = as.POSIXct(
                strptime("2018-01-10 00:00:00", format = "%Y-%m-%d %H:%M:%S")
              ),
              con=pool))# 37-70 s maison # 10.5 EPTB
#} # end if interactive

debit_barrage <-traitement_siva(debit_barrage)

pool:poolClose(pool)
```
```{r calcul_plot_debit_journalier}
# chargement des paramètres du barrage
load(system.file("param2012_2014.Rdata", package = "SIVA"))
Q12345 <- debit_total(param, param0 = param, debit_barrage)
Q12345$tot_vol <- debit_barrage$tot_vol # volume total au barrage d'Arzal
Q12345$volet_vanne <-
  debit_barrage$tot_vol_barrage + debit_barrage$tot_vol_volet # volume total toutes les dix minutes sur volets et vannes
mQ <-
  reshape2::melt(
    Q12345[, c("horodate",
               "qvanne1",
               "qvanne2",
               "qvanne3",
               "qvanne4",
               "qvanne5")],
    id.vars = "horodate",
    value.name = "Qvanne",
    variable.name = "vanne"
  )
mcond <-
  reshape2::melt(Q12345[, c("horodate",
                            "typecalc1",
                            "typecalc2",
                            "typecalc3",
                            "typecalc4",
                            "typecalc5")], value.name = "typecalc", id.vars = "horodate")
mQ$vanne <- as.character(mQ$vanne)
mQ$vanne <- gsub("qvanne", "", mQ$vanne)
mQ12345 <- cbind(mQ, "typecalc" = mcond[, 3]) # melted object


g <-ggplot2::ggplot(mQ12345, ggplot2::aes(
  x = horodate,
  y = Qvanne,
  col = typecalc,
  shape = vanne
)) + ggplot2::geom_jitter(size = 0.6)

print(g)

# Calcul du débit journalier
Qj <-
  as.data.frame(
    dplyr::select(
      Q12345,
      Q,
      date,
      volvoletcalcule,
      debit_moyen_cran,
      tot_vol,
      volet_vanne,
      tot_vol_siphon,
      tot_vol_passe
    ) %>%
      dplyr::group_by(date) %>%
      dplyr::summarize(
        volumevilainecalcule = 
          sum(Q * 600, volvoletcalcule, tot_vol_passe, tot_vol_siphon, na.rm =TRUE),
        tot_vol = sum(tot_vol, na.rm = TRUE),
        volet_vanne = sum(volet_vanne),
        debit_moyen_cran = mean(debit_moyen_cran)
      ) %>%
      dplyr::mutate(
        debitvilainecalcule = volumevilainecalcule / (24 * 60 * 60),
        tot_bar = tot_vol / (24 * 60 * 60),
        tot_volvan_bar = volet_vanne / (24 * 60 * 60)
      )
  )


Qj %>% select(date|  starts_with("debit")) %>% 
  rename(debit_vilaine_calcule=debitvilainecalcule) %>%
  pivot_longer(cols=starts_with("debit"),names_to = "source",values_to = "Q") %>%
  ggplot() + geom_point(aes(x=date,y=Q, col=source)) +
  geom_line(aes(x=date,y=Q, col=source))

```



```{r graphes niveaux}
niveaux <- debit_barrage %>% select(horodate, niveauvilaineb,
                                    niveaumerb) %>%
  rename(horodate = horodate) %>% # todo get rid of horodate in code
  pivot_longer(
    cols = c("niveauvilaineb", "niveaumerb"),
    names_to = "source",
    names_prefix = "niveau",
    values_to = "niveau"
  )
debits_vannes <-
  Q12345 %>% select(horodate, starts_with("Qvanne")) %>%
  pivot_longer(
    cols = starts_with("Qvanne"),
    names_to = "vanne",
    names_prefix = "qvanne",
    values_to = "Q"
  )
debits_volets <-
  Q12345 %>% select(horodate, starts_with("Qvolet")) %>%
  pivot_longer(
    cols = starts_with("Qvolet"),
    names_to = "volet",
    names_prefix = "Qvolet",
    values_to = "Q"
  )


g1 <- ggplot()+ geom_line(aes(x=horodate, y=niveau, col=source), data=niveaux) 
g2 <- ggplot()+  geom_line(aes(x=horodate, y=Q, col=vanne), data=debits_vannes)+ geom_line(aes(x=horodate, y=Q, col=volet), data=debits_volets)
plotly::ggplotly(g1)
plotly::ggplotly(g2)



```


```{r graphes debitniveau armchart}
#install.packages("rAmCharts")
library("rAmCharts")
debit_barrage %>% 
  amTimeSeries(
    'horodate',
    c("niveaumerb", "niveauvilaineb"),
    bullet = c("round", "square"),
    color = col <-
      c("orange", "limegreen"),
    #"yellow","#39CCCC")
    backgroundColor = "#40555E",
    backgroundAlpha = 0.4,
    bulletSize = c(6, 4),
    aggregation = "Average",
    fillAlphas = c(0.1, 0.1),
    groupToPeriods = c('10mm', '30mm', 'hh', 'DD', 'MM', 'MAX'),
    #  c('hh', 'DD', '10DD','MM','MAX'),
    linewidth = c(0.2, 0.2),
    legend = TRUE,
    # maxSeries = 200,
    categoryAxesSettings.minPeriod = "30mm"
  ) %>%
  setExport(enabled = TRUE)   


```

# traitement des données de niveau


```{r loadniveaux}


if (!exists("mainpass")) mainpass <- getPass::getPass(msg = "main password")
if (!exists("hostmysql")) {
  hostmysql. <- getPass::getPass(msg = "Saisir host")
  # ci dessous pour ne pas redemander au prochain tour
  hostmysql <- encrypt_string(string = hostmysql., key = mainpass)
} else {
  hostmysql. <- decrypt_string(string = hostmysql, key = mainpass)
}
if (!exists("pwdmysql")) {
  pwdmysql. <- getPass::getPass(msg = "Saisir password")
  pwdmysql <- encrypt_string(string = pwdmysql., key = mainpass)
}  else {
  # pass should be loaded
  pwdmysql. <- decrypt_string(string = pwdmysql, key = mainpass)
}
if (!exists("umysql")) {
  umysql. <- getPass::getPass(msg = "Saisir user")
  umysql <- encrypt_string(string = umysql., key = mainpass)
} else {
  umysql. <- decrypt_string(string = umysql, key = mainpass)
}
# attention il faut avaoir définit mainpass <- "xxxxx"

pool <- pool::dbPool(
  drv = RMariaDB::MariaDB(),
  dbname = "archive_IAV",
  host = hostmysql.,
  username = umysql.,
  password = pwdmysql.,
  port=3306
)



niveaux2 <-
  load_niveaux(
    debut = as.POSIXct(strptime("2021-01-01 00:00:00",
                                format = "%Y-%m-%d %H:%M:%S")),
    fin = as.POSIXct(strptime("2021-01-10 00:00:00",
                              format = "%Y-%m-%d %H:%M:%S")),
    tags = c(2507, 2508, 2100, 1000, 
             1100,1300,1400,1902,2000),
    con = pool
  )

poolClose(pool)

```
```{r graphes niveau armchart}
#install.packages("rAmCharts")


library("rAmCharts")
niveaux2 %>%
  amTimeSeries(
    'horodate',
    c("vilaine_barrage",
      "mer_barrage",
      "redon_ecluse",
      "aucfer",
      "molac",
      "legueslin",
      "sixtsuraff",
      "pontdecran",
      "guerouet"
    ),
    bullet = "round",
    color =   randomcoloR::distinctColorPalette(9),
    #backgroundColor = "#40555E",
    #backgroundAlpha = 0.4,
    bulletSize =  4,
    aggregation = "Average",
    fillAlphas = 0.1,
    groupToPeriods = c('10mm', '30mm', 'hh', 'DD', 'MM', 'MAX'),
    #  c('hh', 'DD', '10DD','MM','MAX'),
    linewidth = 0.2,
    legend = TRUE,
    # maxSeries = 200,
    categoryAxesSettings.minPeriod = "30mm"
  ) %>%
  setExport(enabled = TRUE)   


```
