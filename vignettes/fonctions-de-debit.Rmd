---
title: "fonctions-de-debit"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fonctions-de-debit}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8, fig.height = 6
)
```

```{r setup}
library(SIVA)
```

<!-- WARNING - This vignette is generated by {fusen} from /dev/flat_debit.Rmd: do not edit by hand -->

# Débit d'une vanne : debit_vanne

Deux conditions sont utilisées pour les vannes, (1) le canal (la vanne
est hors d'eau) et (2) l'orifice noyé.

(1) Pour la loi de canal deux conditions sont proposées dans la formule
    du logiciel Infoworks: $h_2/h_1<=0.98$ écoulement libre,
    $h_2/h_1>0.98$ écoulement noyé. En pratique, dans le cas des très
    grandes ouvertures de vanne, les écoulements libres sont assez
    rares. Pour le calcul des coefficients de débits, des paramètres un
    peu arbitraires ont été choisis (10 m de longueur de radier dans la
    formule $C_d$). Dans le cas où l'écoulement est noyé par l'aval la
    formule canal s'écrit (source Infoworks):

$$      
\begin{align*}
C_d=&(1-0.01\frac{10}{l})\left(10(1-\frac{0.01}{2h_1})\right)^{1.5}\\   
Q_{va}=&C_d \mu_{vw}(\frac{2}{3})^{1.5} g^{0.5} l h_1 (\frac{h_1-h_2}{1-0.98})^{0.5}                
\end{align*}
$$

Dans le cas où l'écoulement est libre la formule est plus simple (source
Infoworks):

$$      
\begin{align*}  
Q_{va}=&C_d \mu_{vw}(\frac{2}{3})^{1.5} g^{0.5} l h_1 ^{1.5}                
\end{align*}
$$

Pour l'orifice noyé, deux conditions de noyage de la vanne sont
considérés. Nous avons en pratique calé deux coefficients séparés pour
les conditions où la vanne est fortement noyée ($h_1\geq1.5h_0$) et les
conditions ou elle sort plus de l'eau ($h_1<1.5h_0$) $$
\begin{align*}
C_e=&0.61(1+0.15\frac{l+2h_0}{(2l+2h_0})\\
\end{align*} 
$$ $$
Q=
\begin{cases}
C_e\mu_{vg}h_0l(2g\Delta)^{0.5}~si~h_1<1.5h_0\\
C_e\mu_{vgs}h_0l(2g\Delta)^{0.5}~si~h_1\geq1.5h_0
\end{cases} 
$$

**Fonction de calcul de débit pour une vanne**

Choisir `canal="bazin"` pour avoir les calculs qui étaient fait avant
2018 au barrage. Aubuisson et horton pour calculer les débits suivant
Ferrette (2004) en prenant ou non compte des vitesses Par rapport à
Ferette (2004), la formule en orifice dénoyé calcule les vitesses par
iteration. Le calcul est effectué à partir d'une indexation des
conditions de débits (vecteur de valeurs vrai et faux) entre crochet.
Les coefficients de Bazin ont été recalculés par une 'regression' loess
sur la base du rapport annexé à Briand et Woimant (2015)

```{r examples-debit_vanne}


# utilisation de la fonction de débit pour une vanne
# chargement des paramètres et des données de la base
param <- SIVA::param
dat <- SIVA::dat2019

# Pour obtenir de l'aide sur le calcul de débit lancer : ? debit_vanne


# Calcul du débit d'une vanne
Qva1 <-
  debit_vanne(
    hvilaine = dat$niveauvilaineb,
    hmer = dat$niveaumerb,
    hvanne = dat$vanne1,
    canal = "ifsw",
    Cvg = param["Cvg"],
    Cvgs = param["Cvgs"],
    Cvw = param["Cvw"],
    loi_orificenoye = "ifws"
  )
plot(Qva1[4000:5000,])


```

# Débit de l'ensemble des vannes : debit_vannes

```{r example-debit_vannes}
# chargement des paramètres
param <- SIVA::param
# les valeurs ajustées des paramètres sont
knitr::kable(param)
dat <- SIVA::dat2019
head(dat)

```

## Pour mémoire : récupération et Calage pour formule de Bazin

```{r pour_info}

# Exploration des coefficients la formule de Bazin 

H=c(5:11)
Rh=c(2,2.25,2.5,2.8,3,3.2,3.4)
K=c(118,125,133,140,146,152,156)
plot(Rh,K)
points(Rh,predict(lm(K~Rh)),type="l")
gamma=87*Rh/(K+sqrt(Rh))
plot(H,gamma,pch="A")
df<-data.frame(H=H,gamma=gamma)
loess_gamma_bazin<-loess(gamma~H,data=df,control = loess.control(surface = "direct")) # contol pour extrapolation en dehors de la gamme
#save(loess_gamma_bazin,file=str_c(datawd,"loess_gamma_bazin.Rdata"))
df2<-data.frame(H=seq(from=5,to=11,by=0.1)) # pour les prédictions
df2$gamma<-predict(loess_gamma_bazin,newdata=df2)
points(df2$H,df2$gamma,col="red")

```


# Débit d'un volet : debit_volet

Le fonctionnement en volet est déduit de l'absence d'ouverture de vanne,
de la position du codeur, du niveau Vilaine et du niveau mer. Il semble,
mais ce point reste à confirmer, que la formule par défaut du barrage ne
calcule que pour les positions de codeur au dessus du fin de course
(\>1.38). La hauteur du volet varie en théorie entre 1.38 et 4.03 m NGF.
En pratique il y a des dérives du niveau du codeur qui font qu'on ne
peut utiliser que l'information sur la baisse du volet et une valeur
approximative permettant de sélectionner les positions volet ouvert
(\<3.5m).

$$
\begin{align*}
si~&h_{vilaine}\geq 1.38~\& \\
&h_{volet}<3.5~\&\\
&h_0=0~\&\\
&h_{vilaine}>h_{mer}+0.3\\
&Q_{vo}=l'*\mu_{vo}(\frac{2}{3}g)^{0.5}(h_{vilaine}-1.38)^{1.5}
\end{align*}
$$




```{r example-debit_volet}
param <- SIVA::param
dat <- SIVA::dat2019
dv <-debit_volet(
  hvolet = dat$volet1,
  hvilaine = dat$niveauvilaine,
  hvanne = dat$vanne1,
  hmer = dat$niveaumer,
  Cvo = param["Cvo"]
)
```

# Débit de l'ensemble des volets : debit_volets


Le débit recalculé par les formules est rapporté en noir, le débit calculé au 
niveau du barrage est rapporté en rouge (totaliseur de volume).

```{r example-debit_vol}

dat <- head(SIVA::dat2019,5000)
Qvo12345 <- debit_volets(
  hvolet1 = dat$volet1,
  hvolet2 = dat$volet2,
  hvolet3 = dat$volet3,
  hvolet4 = dat$volet4,
  hvolet5 = dat$volet5,
  hvilaine = dat$niveauvilaine,
  hmer = dat$niveaumer,
  hvanne1 = dat$vanne1,
  hvanne2 = dat$vanne2,
  hvanne3 = dat$vanne3,
  hvanne4 = dat$vanne4,
  hvanne5 = dat$vanne5,
  Cvo = param["Cvo"]
)
plot(
  dat$horodate,
  rowSums(Qvo12345) * 600,
  pch = 19,
  cex = 0.5,
  ylab = "volume 10 min"
)
points(
  dat$horodate,
  dat$tot_vol_volet,
  pch = 19,
  cex = 0.2,
  col = "red"
)


datt <- dat
datt$volvoletcalcule <- rowSums(Qvo12345) * 600
datt$date = as.Date(datt$horodate)
debj <-
  as.data.frame(
    dplyr::select(datt, date, tot_vol_volet, volvoletcalcule) %>%
      dplyr::group_by(date) %>%
      dplyr::summarize(
        volumevoletcalcule = sum(volvoletcalcule),
        volumevoletbarrage = sum(tot_vol_volet)
      ) %>%
      dplyr::mutate(
        debitvoletcalcule = volumevoletcalcule / (24 * 60 * 60),
        debitvoletbarrage = volumevoletbarrage / (24 * 60 * 60)
      )
  )

plot(
  debj$date,
  debj$debitvoletcalcule,
  type = "l",
  col = "black",
  ylab = "Debit (m3/s)",
  xlab = "Date",
  ylim = c(0, max(
    c(debj$debitvoletcalcule, debj$debitvoletbarrage), na.rm = TRUE
  ))
)
points(debj$date,
       debj$debitvoletbarrage,
       type = "l",
       col = "red")
legend(
  "top",
  legend = c("calcul", "barrage"),
  col = c("black", "red"),
  lty = c(1, 1)
)

```

# Débit de l'ensemble du barrage : debit_total

Les données de SIVA étant enregistrées au pas de temps de dix minutes,
le débit instantanné au barrage $Q_{ba}$ s'écrit : $$
Q_{ba}(t)=\frac{\sum_{i=1}^5 \beta Q_{va}(t,i)+\sum_{i=1}^5 \beta
Q_{vo}(t,i)+V_{s}+V_{p}+V_{e}}{\beta}
$$
Avec : 

$V_s$= volume siphon 

$V_p$=volume passe  

$V_e$=volume écluse


$\beta$=600

Les écoulements passe $V_p$ et siphon $V_s$, qui sont faible, ne sont
pas recalculés et viennent directement de SIVA. Les Volumes écluse ne
sont pas inclus dans la formule. 

<!-- TODO voir avec Aldo.-->

```{r example-debit_total}
param <- SIVA::param
dat <- SIVA::dat2019
Q12345 <- debit_total(param, param0 = param, dat2019)
Q12345$tot_vol <- dat$tot_vol # volume total au barrage d'Arzal
Q12345$volet_vanne <-
  dat$tot_vol_vanne + dat$tot_vol_volet # volume total toutes les dix minutes sur volets et vannes
mQ <-
  reshape2::melt(
    Q12345[, c("horodate",
               "qvanne1",
               "qvanne2",
               "qvanne3",
               "qvanne4",
               "qvanne5")],
    id.vars = "horodate",
    value.name = "Qvanne",
    variable.name = "vanne"
  )
mcond <-
  reshape2::melt(Q12345[, c("horodate",
                  "typecalc1",
                  "typecalc2",
                  "typecalc3",
                  "typecalc4",
                  "typecalc5")], value.name = "typecalc", id.vars = "horodate")
mQ$vanne <- as.character(mQ$vanne)
mQ$vanne <- gsub("qvanne", "", mQ$vanne)
mQ12345 <- cbind(mQ, "typecalc" = mcond[, 3]) # melted object


g <-ggplot2::ggplot(mQ12345, ggplot2::aes(
  x = horodate,
  y = Qvanne,
  col = typecalc,
  shape = vanne
)) + ggplot2::geom_jitter(size = 0.6)

print(g)

# Calcul du débit journalier
Qj <-
  as.data.frame(
    dplyr::select(
      Q12345,
      Q,
      date,
      volvoletcalcule,
      debit_moyen_cran,
      tot_vol,
      volet_vanne,
      tot_vol_siphon,
      tot_vol_passe
    ) %>%
      dplyr::group_by(date) %>%
      dplyr::summarize(
        volumevilainecalcule = sum(Q * 600, volvoletcalcule, tot_vol_passe, tot_vol_siphon, na.rm =TRUE),
        tot_vol = sum(tot_vol, na.rm = TRUE),
        volet_vanne = sum(volet_vanne),
        debit_moyen_cran = mean(debit_moyen_cran)
      ) %>%
      dplyr::mutate(
        debitvilainecalcule = volumevilainecalcule / (24 * 60 * 60),
        tot_bar = tot_vol / (24 * 60 * 60),
        tot_volvan_bar = volet_vanne / (24 * 60 * 60)
      )
  )
```

# Extraction des données à l'aide des fonctions SIVA : bilansiva-debit

Utilisation de bilansiva pour extraire les débits du barrage. Le tableau
dans cette forme peut être utilisé directement dans les fonctions de
débit.

```{r example-bilansiva_debit}
# Ne pas oublier que la bdd du barrage est en vieux GMT tout pourri.
Sys.setenv(TZ='GMT')	

# mise en place des paramètres de connexion --------------------
 # sur mon ordi j'ai des mots de passe chargés au démarrage à partir de Rprofile.site
 # Ici test si existent et si oui il faut le main password pour les decrypter, sinon il
 # faut les entrer après un prompt du programme. 
 if (interactive()){
 if (!exists("mainpass")) mainpass <- getPass::getPass(msg = "main password")
 if (!exists("hostmysql")) {
   hostmysql. <- getPass::getPass(msg = "Saisir host")
   # ci dessous pour ne pas redemander au prochain tour
   hostmysql <- encrypt_string(string = hostmysql., key = mainpass)
 } else {
   hostmysql. <- decrypt_string(string = hostmysql, key = mainpass)
 }
 if (!exists("pwdmysql")) {
   pwdmysql. <- getPass::getPass(msg = "Saisir password")
   pwdmysql <- encrypt_string(string = pwdmysql., key = mainpass)
 }  else {
   # pass should be loaded
   pwdmysql. <- decrypt_string(string = pwdmysql, key = mainpass)
 }
 if (!exists("umysql")) {
   umysql. <- getPass::getPass(msg = "Saisir user")
   umysql <- encrypt_string(string = umysql., key = mainpass)
 } else {
   umysql. <- decrypt_string(string = umysql, key = mainpass)
 }
 
 pool <- pool::dbPool(
     drv = RMariaDB::MariaDB(),
     dbname = "archive_IAV",
     host = hostmysql.,
     username = umysql.,
     password = pwdmysql.,
     port=3306
 )
 dat <- load_debit_barrage(debut="2020-01-01 00:00:00",
     fin="2020-01-20 00:00:00",
     con=pool)
 knitr::kable(dat)
 rawdata2020 <- dat
 save(rawdata2020, file="../inst/rawdata2020.Rdata")
 }
```

# Traitement des données en sortie de bilansiva-debit : traitement_siva

Le débit du barrage est stocké dans des totaliseurs, le traitement SIVA

-   Transforme les cumuls en différences

-   vire les cumuls négatifs lors de la remise à jour des totaliseurs

-   vire les valeurs trop grandes apparaissant lors des différence sur
    plantage de la base

-   filtre les débits erronés des siphons \> 3.8 $m^3s^{-1}$

```{r example-traitement_siva}
# voir example-bilansiva-debit pour le chargement des données de 2020 dans SIVA
load(system.file("rawdata2020.Rdata", package="SIVA"))
plot(rawdata2020$tot_vol_vanne)
# les totaliseurs sont remis à plat
cordata2020 <- traitement_siva(dat=rawdata2020)
plot(cordata2020$tot_vol_vanne)
```
